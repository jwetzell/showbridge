/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Transforms to be performed
 */
export type TransformList = (Scale | Round | Floor | Log1 | Power | Map | Template)[];
/**
 * key of the variable to store ran through templating
 */
export type Key = string;
/**
 * value of the variable to store ran through templating
 */
export type Value = string;
/**
 * JS template of the MIDI port to send on
 */
export type Port = string;
/**
 * JS template of the MIDI port to send on
 */
export type Port1 = string;
/**
 * JS template of the MIDI port to send on
 */
export type Port2 = string;
/**
 * JS template of the MIDI port to send on
 */
export type Port3 = string;
/**
 * JS template of the MIDI port to send on
 */
export type Port4 = string;
/**
 * JS template of the MIDI port to send on
 */
export type Port5 = string;
/**
 * JS template of the MIDI port to send on
 */
export type Port6 = string;
/**
 * JS template of the MIDI port to send on
 */
export type Port7 = string;
/**
 * JS template of the MIDI port to send on
 */
export type Port8 = string;
/**
 * JS template of the MIDI port to send on
 */
export type Port9 = string;
/**
 * JS template of the MIDI port to send on
 */
export type Port10 = string;
/**
 * JS template of the MIDI port to send on
 */
export type Port11 = string;
/**
 * Template for the hostname or address of the server to forward message to
 */
export type Host = string;
/**
 * Template for the port to forward msg to
 */
export type Port12 = string;
/**
 * Template for the hostname or address of the server to forward message to
 */
export type Host1 = string;
/**
 * Template for the port to send on
 */
export type Port13 = string;
/**
 * JS template of the OSC address. Will have access to the msg object to subsitute in properties of the message that triggered this action
 */
export type Address = string;
/**
 * Array of args. Strings will be ran through the templating engine same as the _address param
 */
export type Args = string[];
/**
 * Template for the hostname or address of the server to forward message to
 */
export type Host2 = string;
/**
 * Template for the port to send msg on
 */
export type Port14 = string;
/**
 * Template for the hostname or address of the server to forward message to
 */
export type Host3 = string;
/**
 * Template for the port to send msg on
 */
export type Port15 = string;
/**
 * Template for the hostname or address of the server to forward message to
 */
export type Host4 = string;
/**
 * Template for the port to send msg on
 */
export type Port16 = string;
/**
 * string to send ran through templating engine
 */
export type String = string;
/**
 * Template for the hostname or address of the server to forward message to
 */
export type Host5 = string;
/**
 * Template for the port to send msg on
 */
export type Port17 = string;
/**
 * Template for the hostname or address of the server to forward message to
 */
export type Host6 = string;
/**
 * Template for the port to send msg on
 */
export type Port18 = string;
/**
 * Template for the hostname or address of the server to forward message to
 */
export type Host7 = string;
/**
 * Template for the port to send msg on
 */
export type Port19 = string;
/**
 * string to send ran through templating engine
 */
export type String1 = string;
/**
 * JS literal template of the shell command to run
 */
export type Command = string;
/**
 * JS literal template of the url. Will have access to the properties of the incoming message that triggered this action
 */
export type Url = string;
/**
 * JS literal template of the body. Will have access to the properties of the incoming message that triggered this action
 */
export type Body = string;
/**
 * the templated MQTT topic to publish the message to
 */
export type Topic = string;
/**
 * the templated payload of the mqtt message
 */
export type Payload = string;
/**
 * the templated body of the HTTP response
 */
export type Body1 = string;
/**
 * the body of the HTTP response
 */
export type Body2 = string;
export type ContentType =
  | "text/plain"
  | "text/html"
  | "text/csv"
  | "application/json"
  | "application/pdf"
  | "image/jpeg"
  | "image/png"
  | "audio/wav"
  | "audio/webm"
  | "video/mp4"
  | "video/mpeg"
  | "video/webm";
/**
 * path to the file that will be read and returned
 */
export type Path = string;
export type ContentType1 =
  | "text/plain"
  | "text/html"
  | "text/csv"
  | "application/json"
  | "application/pdf"
  | "image/jpeg"
  | "image/png"
  | "audio/wav"
  | "audio/webm"
  | "video/mp4"
  | "video/mpeg"
  | "video/webm";
/**
 * array of rooms to template and then send the message to
 */
export type Rooms = string[];
/**
 * array of actions to execute after delaying
 */
export type ActionList1 = (
  | Log
  | Store
  | MIDIOutput
  | Forward
  | OSCOutput
  | UDPOutput
  | TCPOutput
  | ShellCommand
  | HTTPRequest1
  | MQTTOutput
  | HTTPResponse
  | CloudOutput
  | Delay
  | Random
)[];
/**
 * array of actions to randomly pick from
 */
export type ActionList2 = (
  | Log
  | Store
  | MIDIOutput
  | Forward
  | OSCOutput
  | UDPOutput
  | TCPOutput
  | ShellCommand
  | HTTPRequest1
  | MQTTOutput
  | HTTPResponse
  | CloudOutput
  | Delay
  | Random
)[];
/**
 * Actions to be performed if this trigger is fired
 */
export type ActionList = (
  | Log
  | Store
  | MIDIOutput
  | Forward
  | OSCOutput
  | UDPOutput
  | TCPOutput
  | ShellCommand
  | HTTPRequest1
  | MQTTOutput
  | HTTPResponse
  | CloudOutput
  | Delay
  | Random
)[];
/**
 * List of triggers
 */
export type TriggerList = (
  | Any
  | Regex
  | Sender
  | BytesEqual
  | HTTPRequest
  | MIDINoteOff
  | MIDINoteOn
  | MIDIControlChange1
  | MIDIProgramChange1
)[];
/**
 * Name of the virtual MIDI Input port
 */
export type VirtualInputName = string;
/**
 * Name of the virtual MIDI Output port
 */
export type VirtualOutputName = string;

/**
 * config JSON layout
 */
export interface ConfigFileSchema {
  http: HTTP;
  ws: WebSocket;
  osc: OSC;
  tcp: TCP;
  udp: UDP;
  midi: MIDI;
  mqtt: MQTT;
  cloud?: Cloud;
  [k: string]: unknown;
}
export interface HTTP {
  params: {
    /**
     * Address to listen on defaults to 0.0.0.0
     */
    address?: string;
    /**
     * TCP port to listen on (this will be the same port used for websocket connections
     */
    port: number;
  };
  /**
   * array of triggers
   */
  triggers: (HTTPRequest | Sender | Regex | Any)[];
}
/**
 * This trigger will match http requests by method and/or path
 */
export interface HTTPRequest {
  type: "http-request";
  comment?: string;
  /**
   * HTTP Request trigger params
   */
  params: {
    /**
     * exact HTTP path to match
     */
    path?: string;
    /**
     * The HTTP method to match i.e GET, POST, PUT
     */
    method?: "get" | "post" | "put" | "delete" | "patch" | "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
  };
  actions?: ActionList;
  subTriggers?: TriggerList;
  /**
   * Whether this trigger is enabled
   */
  enabled: boolean;
}
/**
 * This action logs out the incoming message
 */
export interface Log {
  type: "log";
  comment?: string;
  transforms?: TransformList;
  /**
   * Whether this action is enabled
   */
  enabled: boolean;
}
/**
 * This transform will scale the incoming message property
 */
export interface Scale {
  type: "scale";
  comment?: string;
  /**
   * Scale transform params
   */
  params: {
    /**
     * the property of the incoming message to scale
     */
    property: string;
    /**
     * the range of the incoming numbers i.e [0,100]
     *
     * @minItems 2
     * @maxItems 2
     */
    inRange: [number, number];
    /**
     * the range of the outgoing numbers i.e [1,10]
     *
     * @minItems 2
     * @maxItems 2
     */
    outRange: [number, number];
  };
  /**
   * Whether this transform is enabled
   */
  enabled: boolean;
}
/**
 * This transform will round the incoming message property
 */
export interface Round {
  type: "round";
  comment?: string;
  /**
   * Round transform params
   */
  params: {
    /**
     * the property of the incoming message to round
     */
    property: string;
  };
  /**
   * Whether this transform is enabled
   */
  enabled: boolean;
}
/**
 * This transform will floor the incoming message property
 */
export interface Floor {
  type: "floor";
  comment?: string;
  /**
   * Floor transform params
   */
  params: {
    /**
     * the property of the incoming message to floor
     */
    property: string;
  };
  /**
   * Whether this transform is enabled
   */
  enabled: boolean;
}
/**
 * This transform will take the log of the incoming message property
 */
export interface Log1 {
  type: "log";
  comment?: string;
  /**
   * Log transform params
   */
  params: {
    /**
     * the property of the incoming message
     */
    property: string;
    /**
     * the log base
     */
    base: number;
  };
  /**
   * Whether this transform is enabled
   */
  enabled: boolean;
}
/**
 * This transform will take the configured power of the incoming message property
 */
export interface Power {
  type: "power";
  comment?: string;
  /**
   * Power transform params
   */
  params: {
    /**
     * the property of the incoming message that will be used as the base of the exponent
     */
    property: string;
    /**
     * the exponent to raise the property value to
     */
    exponent: number;
  };
  /**
   * Whether this transform is enabled
   */
  enabled: boolean;
}
/**
 * This transform will map the incoming message property
 */
export interface Map {
  type: "map";
  comment?: string;
  /**
   * map transform params
   */
  params: {
    /**
     * the property of the incoming message to map
     */
    property: string;
    /**
     * key:value object to lookup the property value in and the resulting value to map it to
     */
    map: {
      [k: string]: unknown;
    };
  };
  /**
   * Whether this transform is enabled
   */
  enabled: boolean;
}
/**
 * This transform will template the incoming message property
 */
export interface Template {
  type: "template";
  comment?: string;
  /**
   * Template transform params
   */
  params: {
    /**
     * the property of the incoming message to populate
     */
    property: string;
    /**
     * the template whose result will replace the property value. will have access to the msg object
     */
    template: string;
  };
  /**
   * Whether this transform is enabled
   */
  enabled: boolean;
}
/**
 * This action stores the configured value in a global vars object. Which will be made available when templating things.
 */
export interface Store {
  type: "store";
  comment?: string;
  transforms?: TransformList;
  /**
   * Store action params
   */
  params: {
    _key?: Key;
    /**
     * key of the variable to store
     */
    key?: string;
    _value?: Value;
    /**
     * value of the variable to store
     */
    value?: string;
  };
  /**
   * Whether this action is enabled
   */
  enabled: boolean;
}
/**
 * This action will output MIDI using raw MIDI data byte array
 */
export interface MIDIOutput {
  type: "midi-output";
  comment?: string;
  transforms?: TransformList;
  /**
   * MIDI output action params
   */
  params:
    | MIDIBytes
    | MIDINoteOffMessage
    | MIDINoteOnMessage
    | MIDIPolyphonicAftertouch
    | MIDIControlChange
    | MIDIProgramChange
    | MIDIChannelAftertouch
    | MIDIPitchBend
    | MIDIStart
    | MIDIContinue
    | MIDIStop
    | MIDIReset;
  /**
   * Whether this action is enabled
   */
  enabled: boolean;
}
export interface MIDIBytes {
  /**
   * the MIDI port to send on
   */
  port?: string;
  _port?: Port;
  /**
   * MIDI data to be sent as an array of 3 bytes
   *
   * @minItems 2
   * @maxItems 3
   */
  bytes: [number, number] | [number, number, number];
}
export interface MIDINoteOffMessage {
  /**
   * the MIDI port to send on
   */
  port?: string;
  _port?: Port1;
  /**
   * MIDI status value
   */
  status: "note_off";
  /**
   * MIDI channel number
   */
  channel: number;
  /**
   * MIDI note value
   */
  note: number;
  /**
   * MIDI velocity value
   */
  velocity: number;
}
export interface MIDINoteOnMessage {
  /**
   * the MIDI port to send on
   */
  port?: string;
  _port?: Port2;
  /**
   * MIDI status value
   */
  status: "note_on";
  /**
   * MIDI channel number
   */
  channel: number;
  /**
   * MIDI note value
   */
  note: number;
  /**
   * MIDI velocity value
   */
  velocity: number;
}
export interface MIDIPolyphonicAftertouch {
  /**
   * the MIDI port to send on
   */
  port?: string;
  _port?: Port3;
  /**
   * MIDI status value
   */
  status: "polyphonic_aftertouch";
  /**
   * MIDI channel number
   */
  channel: number;
  /**
   * MIDI note value
   */
  note: number;
  /**
   * MIDI pressure value
   */
  pressure: number;
}
export interface MIDIControlChange {
  /**
   * the MIDI port to send on
   */
  port?: string;
  _port?: Port4;
  /**
   * MIDI status value
   */
  status: "control_change";
  /**
   * MIDI channel number
   */
  channel?: number;
  /**
   * MIDI control value
   */
  control: number;
  /**
   * MIDI value
   */
  value: number;
}
export interface MIDIProgramChange {
  /**
   * the MIDI port to send on
   */
  port?: string;
  _port?: Port5;
  /**
   * MIDI status value
   */
  status: "program_change";
  /**
   * MIDI channel number
   */
  channel?: number;
  /**
   * MIDI program value
   */
  program: number;
}
export interface MIDIChannelAftertouch {
  /**
   * the MIDI port to send on
   */
  port?: string;
  _port?: Port6;
  /**
   * MIDI status value
   */
  status: "channel_aftertouch";
  /**
   * MIDI channel number
   */
  channel?: number;
  /**
   * MIDI pressure value
   */
  pressure: number;
}
export interface MIDIPitchBend {
  /**
   * the MIDI port to send on
   */
  port?: string;
  _port?: Port7;
  /**
   * MIDI status value
   */
  status: "pitch_bend";
  /**
   * MIDI channel number
   */
  channel?: number;
  /**
   * MIDI value
   */
  value: number;
}
export interface MIDIStart {
  /**
   * the MIDI port to send on
   */
  port?: string;
  _port?: Port8;
  /**
   * MIDI status value
   */
  status: "start";
}
export interface MIDIContinue {
  /**
   * the MIDI port to send on
   */
  port?: string;
  _port?: Port9;
  /**
   * MIDI status value
   */
  status: "continue";
}
export interface MIDIStop {
  /**
   * the MIDI port to send on
   */
  port?: string;
  _port?: Port10;
  /**
   * MIDI status value
   */
  status: "stop";
}
export interface MIDIReset {
  /**
   * the MIDI port to send on
   */
  port?: string;
  _port?: Port11;
  /**
   * MIDI status value
   */
  status: "reset";
}
/**
 * This action will forward the incoming message to the configured destination
 */
export interface Forward {
  type: "forward";
  comment?: string;
  transforms?: TransformList;
  /**
   * forward action params
   */
  params: {
    /**
     * Hostname or address of the server to forward message to
     */
    host?: string;
    _host?: Host;
    /**
     * Port to forward msg to
     */
    port?: number;
    _port?: Port12;
    /**
     * Protocol to use when forwarding msg
     */
    protocol: "udp" | "tcp";
  };
  /**
   * Whether this action is enabled
   */
  enabled: boolean;
}
/**
 * This action will send an OSC message to the configure address:port with the configured address and args
 */
export interface OSCOutput {
  type: "osc-output";
  comment?: string;
  transforms?: TransformList;
  /**
   * OSC output action params
   */
  params: {
    /**
     * Hostname or address of the server to send OSC to
     */
    host?: string;
    _host?: Host1;
    /**
     * Port to send OSC to
     */
    port?: number;
    _port?: Port13;
    /**
     * Protocol to use when sending OSC
     */
    protocol: "udp" | "tcp";
    _address?: Address;
    /**
     * Hardcoded OSC address. _address has priority
     */
    address?: string;
    _args?: Args;
    /**
     * Hardcoded array of OSC args
     */
    args?: string[];
  };
  /**
   * Whether this action is enabled
   */
  enabled: boolean;
}
/**
 * This action will send a UDP packet to the configured address:port with the configured contents
 */
export interface UDPOutput {
  type: "udp-output";
  comment?: string;
  transforms?: TransformList;
  /**
   * UDP output action params
   */
  params: UDPBytes | UDPHex | UDPString;
  /**
   * Whether this action is enabled
   */
  enabled: boolean;
}
export interface UDPBytes {
  /**
   * Hostname or address of the server to send UDP packet to
   */
  host?: string;
  _host?: Host2;
  /**
   * Port to send UDP packet to
   */
  port?: number;
  _port?: Port14;
  /**
   * bytes to send
   */
  bytes: number[];
}
export interface UDPHex {
  /**
   * Hostname or address of the server to send UDP packet to
   */
  host?: string;
  _host?: Host3;
  /**
   * Port to send UDP packet to
   */
  port?: number;
  _port?: Port15;
  /**
   * hex string to be sent as bytes (i.e 68 69, 6869, 0x68 0x69, 0x68,0x69)
   */
  hex: string;
}
export interface UDPString {
  /**
   * Hostname or address of the server to send UDP packet to
   */
  host?: string;
  _host?: Host4;
  /**
   * Port to send UDP packet to
   */
  port?: number;
  _port?: Port16;
  _string?: String;
  /**
   * string to send
   */
  string?: string;
  [k: string]: unknown;
}
/**
 * This action will send a TCP packet to the configured address:port with the configured contents
 */
export interface TCPOutput {
  type: "tcp-output";
  comment?: string;
  transforms?: TransformList;
  /**
   * TCP output action params
   */
  params: TCPBytes | TCPHex | TCPString;
  /**
   * Whether this action is enabled
   */
  enabled: boolean;
}
export interface TCPBytes {
  /**
   * Hostname or address of the server to send TCP packet to
   */
  host?: string;
  _host?: Host5;
  /**
   * Port to send TCP packet to
   */
  port?: number;
  _port?: Port17;
  /**
   * whether to SLIP encode the TCP bytes
   */
  slip: boolean;
  /**
   * bytes to send
   */
  bytes: number[];
}
export interface TCPHex {
  /**
   * Hostname or address of the server to send TCP packet to
   */
  host?: string;
  _host?: Host6;
  /**
   * Port to send TCP packet to
   */
  port?: number;
  _port?: Port18;
  /**
   * whether to SLIP encode the TCP bytes
   */
  slip: boolean;
  /**
   * hex string to be sent as bytes (i.e 68 69, 6869, 0x68 0x69, 0x68,0x69)
   */
  hex: string;
}
export interface TCPString {
  /**
   * Hostname or address of the server to send TCP packet to
   */
  host?: string;
  _host?: Host7;
  /**
   * Port to send TCP packet to
   */
  port?: number;
  _port?: Port19;
  /**
   * whether to SLIP encode the TCP bytes
   */
  slip: boolean;
  _string?: String1;
  /**
   * string to send
   */
  string?: string;
  [k: string]: unknown;
}
/**
 * This action will execute the configured shell command on the system that is running the router
 */
export interface ShellCommand {
  type: "shell";
  comment?: string;
  transforms?: TransformList;
  /**
   * Shell action params
   */
  params: {
    _command?: Command;
    /**
     * Shell command to run
     */
    command?: string;
    [k: string]: unknown;
  };
  /**
   * Whether this action is enabled
   */
  enabled: boolean;
}
/**
 * This command will make the configured http call
 */
export interface HTTPRequest1 {
  type: "http-request";
  comment?: string;
  transforms?: TransformList;
  /**
   * HTTP action params
   */
  params: {
    /**
     * The HTTP method to use i.e GET, POST, PUT
     */
    method: "get" | "post" | "put" | "delete" | "patch" | "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
    _url?: Url;
    /**
     * Url to call
     */
    url?: string;
    /**
     * Content-Type header value mainly useful for POST/PUT/PATCH
     */
    contentType?: string;
    _body?: Body;
    /**
     * Body to include with the request
     */
    body?: string;
  };
  /**
   * Whether this action is enabled
   */
  enabled: boolean;
}
/**
 * This action publishes an MQTT message
 */
export interface MQTTOutput {
  type: "mqtt-output";
  comment?: string;
  transforms?: TransformList;
  params: {
    _topic?: Topic;
    /**
     * the static MQTT topic to publish the message to
     */
    topic?: string;
    _payload?: Payload;
    /**
     * the static payload of the mqtt message
     */
    payload?: string;
  };
  /**
   * Whether this action is enabled
   */
  enabled: boolean;
}
/**
 * This action responds to the incoming http request
 */
export interface HTTPResponse {
  type: "http-response";
  comment?: string;
  transforms?: TransformList;
  params: StringBody | FileBody;
  /**
   * Whether this action is enabled
   */
  enabled: boolean;
}
export interface StringBody {
  _body?: Body1;
  body?: Body2;
  contentType?: ContentType;
}
export interface FileBody {
  /**
   * path to the file that will be read and returned
   */
  path?: string;
  _path?: Path;
  contentType: ContentType1;
}
/**
 * This action will send the incoming message to the specified cloud room
 */
export interface CloudOutput {
  type: "cloud-output";
  comment?: string;
  transforms?: TransformList;
  /**
   * Cloud Output action params
   */
  params: {
    /**
     * array of rooms to send the message to
     */
    rooms?: string[];
    _rooms?: Rooms;
    [k: string]: unknown;
  };
  /**
   * Whether this action is enabled
   */
  enabled: boolean;
}
/**
 * This action will execute the configured actions after the configured amount of time
 */
export interface Delay {
  type: "delay";
  comment?: string;
  transforms?: TransformList;
  /**
   * delay action params
   */
  params: {
    /**
     * time in ms to wait
     */
    duration: number;
    actions: ActionList1;
  };
  /**
   * Whether this action is enabled
   */
  enabled: boolean;
}
/**
 * This action will execute a randomly selected action from the configured subactions
 */
export interface Random {
  type: "random";
  comment?: string;
  transforms?: TransformList;
  /**
   * random action params
   */
  params: {
    actions: ActionList2;
  };
  /**
   * Whether this action is enabled
   */
  enabled: boolean;
}
/**
 * This trigger will match any message
 */
export interface Any {
  type: "any";
  comment?: string;
  actions?: ActionList;
  subTriggers?: TriggerList;
  /**
   * Whether this trigger is enabled
   */
  enabled: boolean;
}
/**
 * This trigger will match the incoming message properties to the regex patterns 1:1
 */
export interface Regex {
  type: "regex";
  comment?: string;
  /**
   * Regex trigger params
   */
  params: {
    /**
     * an array of regex patterns
     */
    patterns: string[];
    /**
     * an array of properties on the msg to match the regex patterns to 1:1
     */
    properties: string[];
  };
  actions?: ActionList;
  subTriggers?: TriggerList;
  /**
   * Whether this trigger is enabled
   */
  enabled: boolean;
}
/**
 * This trigger will match messages by sender
 */
export interface Sender {
  type: "sender";
  comment?: string;
  /**
   * Sender trigger params
   */
  params: {
    /**
     * Address of the server to match incoming messages against
     */
    address: string;
  };
  actions?: ActionList;
  subTriggers?: TriggerList;
  /**
   * Whether this trigger is enabled
   */
  enabled: boolean;
}
/**
 * This trigger will match incoming messages bytes to the ones set in params property
 */
export interface BytesEqual {
  type: "bytes-equal";
  comment?: string;
  /**
   * bytes equal trigger params
   */
  params: {
    /**
     * Array of 3 bytes that will be matched to the incoming message
     */
    bytes: number[];
  };
  actions?: ActionList;
  subTriggers?: TriggerList;
  /**
   * Whether this trigger is enabled
   */
  enabled: boolean;
}
/**
 * The trigger will match incoming MIDI note off events
 */
export interface MIDINoteOff {
  type: "midi-note-off";
  comment?: string;
  /**
   * MIDI note off trigger params
   */
  params: {
    /**
     * name of the MIDI port to match against incoming messages
     */
    port?: string;
    /**
     * channel value to match against incoming the messages
     */
    channel?: number;
    /**
     * Note value to match against incoming the messages
     */
    note?: number;
    /**
     * Velocity value to match against the incoming message
     */
    velocity?: number;
  };
  actions?: ActionList;
  subTriggers?: TriggerList;
  /**
   * Whether this trigger is enabled
   */
  enabled: boolean;
}
/**
 * The trigger will match incoming MIDI note on events
 */
export interface MIDINoteOn {
  type: "midi-note-on";
  comment?: string;
  /**
   * MIDI note on trigger params
   */
  params: {
    /**
     * name of the MIDI port to match against incoming messages
     */
    port?: string;
    /**
     * channel value to match against incoming the messages
     */
    channel?: number;
    /**
     * note value to match against incoming the messages
     */
    note?: number;
    /**
     * velocity value to match against the incoming message
     */
    velocity?: number;
  };
  actions?: ActionList;
  subTriggers?: TriggerList;
  /**
   * Whether this trigger is enabled
   */
  enabled: boolean;
}
/**
 * The trigger will match incoming MIDI control events
 */
export interface MIDIControlChange1 {
  type: "midi-control-change";
  comment?: string;
  /**
   * MIDI control change trigger params
   */
  params: {
    /**
     * name of the MIDI port to match against incoming messages
     */
    port?: string;
    /**
     * channel value to match against incoming the messages
     */
    channel?: number;
    /**
     * control number to match against incoming the messages
     */
    control?: number;
    /**
     * control value to match against the incoming message
     */
    value?: number;
  };
  actions?: ActionList;
  subTriggers?: TriggerList;
  /**
   * Whether this trigger is enabled
   */
  enabled: boolean;
}
/**
 * The trigger will match incoming MIDI program events
 */
export interface MIDIProgramChange1 {
  type: "midi-program-change";
  comment?: string;
  /**
   * MIDI program change trigger params
   */
  params: {
    /**
     * name of the MIDI port to match against incoming messages
     */
    port?: string;
    /**
     * channel value to match against incoming the messages
     */
    channel?: number;
    /**
     * program number to match against incoming the messages
     */
    program?: number;
  };
  actions?: ActionList;
  subTriggers?: TriggerList;
  /**
   * Whether this trigger is enabled
   */
  enabled: boolean;
}
export interface WebSocket {
  /**
   * array of triggers
   */
  triggers: (Sender | Regex | Any)[];
}
export interface OSC {
  /**
   * array of triggers
   */
  triggers: (Sender | Regex | BytesEqual | OSCAddress | Any)[];
}
/**
 * This trigger will match osc messages by address
 */
export interface OSCAddress {
  type: "osc-address";
  comment?: string;
  /**
   * OSC trigger params
   */
  params: {
    /**
     * OSC Address to match. Supports OSC 1.0 address patterns spec *,?,{string1,string2},[a-z],[!a-z]
     */
    address: string;
  };
  actions?: ActionList;
  subTriggers?: TriggerList;
  /**
   * Whether this trigger is enabled
   */
  enabled: boolean;
}
export interface TCP {
  params: {
    /**
     * Address to listen on defaults to 0.0.0.0
     */
    address?: string;
    /**
     * TCP port to listen on
     */
    port: number;
  };
  /**
   * array of triggers
   */
  triggers: (Regex | Sender | BytesEqual | Any)[];
}
export interface UDP {
  params: {
    /**
     * Address to listen on defaults to 0.0.0.0
     */
    address?: string;
    /**
     * UDP port to listen on
     */
    port: number;
  };
  /**
   * array of triggers
   */
  triggers: (Regex | Sender | BytesEqual | Any)[];
}
export interface MIDI {
  params?: {
    virtualInputName?: VirtualInputName;
    virtualOutputName?: VirtualOutputName;
  };
  /**
   * array of triggers
   */
  triggers: (
    | Regex
    | BytesEqual
    | MIDINoteOff
    | MIDINoteOn
    | MIDIControlChange1
    | MIDIPitchBend1
    | MIDIProgramChange1
    | Any
  )[];
}
/**
 * The trigger will match incoming MIDI pitch bend events
 */
export interface MIDIPitchBend1 {
  type: "midi-pitch-bend";
  comment?: string;
  /**
   * MIDI pitch bend trigger params
   */
  params: {
    /**
     * name of the MIDI port to match against incoming messages
     */
    port?: string;
    /**
     * channel value to match against incoming the messages
     */
    channel?: number;
    /**
     * control value to match against the incoming message
     */
    value?: number;
  };
  actions?: ActionList;
  subTriggers?: TriggerList;
  /**
   * Whether this trigger is enabled
   */
  enabled: boolean;
}
export interface MQTT {
  params: {
    /**
     * mqtt broker url
     */
    broker: string;
    /**
     * username for mqtt broker
     */
    username?: string;
    /**
     * password for mqtt broker
     */
    password?: string;
    /**
     * list of topics to subscribe to
     */
    topics: string[];
  };
  /**
   * array of triggers
   */
  triggers: (Regex | MQTTTopic | Any)[];
}
/**
 * This trigger will match mqtt messages by topic
 */
export interface MQTTTopic {
  type: "mqtt-topic";
  comment?: string;
  /**
   * MQTT topic trigger params
   */
  params: {
    /**
     * MQTT topic to match. Supports MQTT topic wildcard patterns +,#
     */
    topic: string;
  };
  actions?: ActionList;
  subTriggers?: TriggerList;
  /**
   * Whether this trigger is enabled
   */
  enabled: boolean;
}
export interface Cloud {
  params: {
    /**
     * cloud url
     */
    url?: string;
    /**
     * list of rooms to join
     */
    rooms?: string[];
  };
}
